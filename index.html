<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chess Game with AI</title>
<style>
  body { font-family: Arial, sans-serif; }
  #board {
    display: grid;
    grid-template-columns: repeat(8, 60px);
    grid-template-rows: repeat(8, 60px);
    width: 480px;
    margin-bottom: 1em;
  }
  .square {
    width: 60px;
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 40px;
    cursor: pointer;
    user-select: none;
  }
  .white {
    background: #f0d9b5;
  }
  .black {
    background: #b58863;
  }
  .highlight {
    outline: 3px solid yellow;
  }
</style>
</head>
<body>
<h2>Chess Game with AI</h2>
<p>Play as White. Click a piece to select it, then click a square to move. The AI plays Black.</p>
<div id="board"></div>
<div id="status"></div>
<script>
let board = [];
let whiteToMove = true;
let selectedSquare = null;
let castlingRights = { whiteKingSide: true, whiteQueenSide: true, blackKingSide: true, blackQueenSide: true };
let enPassantTarget = null;

// initialize board
function initBoard() {
  board = [];
  board.push(['r','n','b','q','k','b','n','r']);
  board.push(['p','p','p','p','p','p','p','p']);
  for (let i=0; i<4; i++) {
    board.push(['','','','','','','','']);
  }
  board.push(['P','P','P','P','P','P','P','P']);
  board.push(['R','N','B','Q','K','B','N','R']);
  whiteToMove = true;
  castlingRights = { whiteKingSide: true, whiteQueenSide: true, blackKingSide: true, blackQueenSide: true };
  enPassantTarget = null;
}

const PIECE_UNICODE = {
  'K':'\u2654','Q':'\u2655','R':'\u2656','B':'\u2657','N':'\u2658','P':'\u2659',
  'k':'\u265A','q':'\u265B','r':'\u265C','b':'\u265D','n':'\u265E','p':'\u265F'
};

function cloneBoard(b) {
  return b.map(row => row.slice());
}
function cloneCastling(c) {
  return { whiteKingSide: c.whiteKingSide, whiteQueenSide: c.whiteQueenSide,
           blackKingSide: c.blackKingSide, blackQueenSide: c.blackQueenSide };
}

function drawBoard() {
  const boardDiv = document.getElementById('board');
  boardDiv.innerHTML = '';
  for (let r=0; r<8; r++) {
    for (let c=0; c<8; c++) {
      const square = document.createElement('div');
      square.classList.add('square');
      if ((r + c) % 2 === 0) square.classList.add('white');
      else square.classList.add('black');
      square.dataset.row = r;
      square.dataset.col = c;
      const piece = board[r][c];
      if (piece) square.textContent = PIECE_UNICODE[piece];
      if (selectedSquare && selectedSquare.row === r && selectedSquare.col === c) {
        square.classList.add('highlight');
      }
      boardDiv.appendChild(square);
    }
  }
}

function coordToAlgebraic(r,c) {
  const files='abcdefgh';
  return files[c] + (8 - r);
}

function isWhitePiece(p) { return p && p === p.toUpperCase(); }
function isBlackPiece(p) { return p && p === p.toLowerCase(); }
function inBounds(r,c) { return r>=0 && r<8 && c>=0 && c<8; }

// Generate pseudo moves for all pieces of given color
function getPseudoMoves(stateBoard, color, stateCastling, stateEnPassant) {
  const moves = [];
  for (let r=0; r<8; r++) {
    for (let c=0; c<8; c++) {
      const piece = stateBoard[r][c];
      if (!piece) continue;
      const pieceColor = isWhitePiece(piece) ? 'white' : 'black';
      if (pieceColor !== color) continue;
      const pt = piece.toLowerCase();
      // pawn moves
      if (pt === 'p') {
        const dir = piece === 'P' ? -1 : 1;
        const startRow = piece === 'P' ? 6 : 1;
        const finalRow = piece === 'P' ? 0 : 7;
        const newRow = r + dir;
        // forward one
        if (inBounds(newRow,c) && !stateBoard[newRow][c]) {
          if (newRow === finalRow) {
            moves.push({ from:[r,c], to:[newRow,c], promotion: piece==='P' ? 'Q' : 'q' });
          } else {
            moves.push({ from:[r,c], to:[newRow,c] });
          }
          if (r === startRow) {
            const twoRow = r + dir*2;
            if (!stateBoard[twoRow][c]) {
              moves.push({ from:[r,c], to:[twoRow,c], enPassant:[newRow,c] });
            }
          }
        }
        // captures
        for (const dc of [-1,1]) {
          const nr = r + dir;
          const nc = c + dc;
          if (!inBounds(nr,nc)) continue;
          const target = stateBoard[nr][nc];
          if (target && ((color === 'white' && isBlackPiece(target)) || (color === 'black' && isWhitePiece(target)))) {
            if (nr === finalRow) {
              moves.push({ from:[r,c], to:[nr,nc], promotion: piece==='P' ? 'Q':'q' });
            } else {
              moves.push({ from:[r,c], to:[nr,nc] });
            }
          }
          // en passant capture
          if (stateEnPassant && stateEnPassant[0] === nr && stateEnPassant[1] === nc) {
            moves.push({ from:[r,c], to:[nr,nc], enPassantCapture:[r,nc] });
          }
        }
      }
      // knight moves
      if (pt === 'n') {
        const offsets = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for (const [dr,dc] of offsets) {
          const nr = r + dr;
          const nc = c + dc;
          if (inBounds(nr,nc)) {
            const target = stateBoard[nr][nc];
            if (!target || ((color === 'white' && isBlackPiece(target)) || (color === 'black' && isWhitePiece(target)))) {
              moves.push({ from:[r,c], to:[nr,nc] });
            }
          }
        }
      }
      // bishop or queen diagonal
      if (pt === 'b' || pt === 'q') {
        const dirs = [[-1,-1],[-1,1],[1,-1],[1,1]];
        for (const [dr,dc] of dirs) {
          let nr = r + dr;
          let nc = c + dc;
          while (inBounds(nr,nc)) {
            const target = stateBoard[nr][nc];
            if (!target) {
              moves.push({ from:[r,c], to:[nr,nc] });
            } else {
              if ((color === 'white' && isBlackPiece(target)) || (color === 'black' && isWhitePiece(target))) {
                moves.push({ from:[r,c], to:[nr,nc] });
              }
              break;
            }
            nr += dr;
            nc += dc;
          }
        }
      }
      // rook or queen straight lines
      if (pt === 'r' || pt === 'q') {
        const dirs = [[-1,0],[1,0],[0,-1],[0,1]];
        for (const [dr,dc] of dirs) {
          let nr = r + dr;
          let nc = c + dc;
          while (inBounds(nr,nc)) {
            const target = stateBoard[nr][nc];
            if (!target) {
              moves.push({ from:[r,c], to:[nr,nc] });
            } else {
              if ((color === 'white' && isBlackPiece(target)) || (color === 'black' && isWhitePiece(target))) {
                moves.push({ from:[r,c], to:[nr,nc] });
              }
              break;
            }
            nr += dr;
            nc += dc;
          }
        }
      }
      // king
      if (pt === 'k') {
        const km = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
        for (const [dr,dc] of km) {
          const nr = r + dr;
          const nc = c + dc;
          if (inBounds(nr,nc)) {
            const target = stateBoard[nr][nc];
            if (!target || ((color === 'white' && isBlackPiece(target)) || (color === 'black' && isWhitePiece(target)))) {
              moves.push({ from:[r,c], to:[nr,nc] });
            }
          }
        }
        // castling
        if (color === 'white' && r === 7 && c === 4) {
          if (stateCastling.whiteKingSide && !stateBoard[7][5] && !stateBoard[7][6]) {
            moves.push({ from:[7,4], to:[7,6], castle:'whiteKingSide' });
          }
          if (stateCastling.whiteQueenSide && !stateBoard[7][3] && !stateBoard[7][2] && !stateBoard[7][1]) {
            moves.push({ from:[7,4], to:[7,2], castle:'whiteQueenSide' });
          }
        }
        if (color === 'black' && r === 0 && c === 4) {
          if (stateCastling.blackKingSide && !stateBoard[0][5] && !stateBoard[0][6]) {
            moves.push({ from:[0,4], to:[0,6], castle:'blackKingSide' });
          }
          if (stateCastling.blackQueenSide && !stateBoard[0][3] && !stateBoard[0][2] && !stateBoard[0][1]) {
            moves.push({ from:[0,4], to:[0,2], castle:'blackQueenSide' });
          }
        }
      }
    }
  }
  return moves;
}

function makeMove(stateBoard, stateCastling, stateEnPassant, mv, color) {
  const newBoard = cloneBoard(stateBoard);
  const newCastling = cloneCastling(stateCastling);
  let newEnPassant = null;
  const [fr,fc] = mv.from;
  const [tr,tc] = mv.to;
  const piece = newBoard[fr][fc];
  // en passant capture
  if (mv.enPassantCapture) {
    const [cr,cc] = mv.enPassantCapture;
    newBoard[cr][cc] = '';
  }
  // move piece
  newBoard[fr][fc] = '';
  if (mv.promotion) {
    newBoard[tr][tc] = mv.promotion;
  } else {
    newBoard[tr][tc] = piece;
  }
  // update castling rights if king moved
  if (piece === 'K') {
    newCastling.whiteKingSide = false;
    newCastling.whiteQueenSide = false;
    if (mv.castle === 'whiteKingSide') {
      newBoard[7][7] = '';
      newBoard[7][5] = 'R';
    } else if (mv.castle === 'whiteQueenSide') {
      newBoard[7][0] = '';
      newBoard[7][3] = 'R';
    }
  }
  if (piece === 'k') {
    newCastling.blackKingSide = false;
    newCastling.blackQueenSide = false;
    if (mv.castle === 'blackKingSide') {
      newBoard[0][7] = '';
      newBoard[0][5] = 'r';
    } else if (mv.castle === 'blackQueenSide') {
      newBoard[0][0] = '';
      newBoard[0][3] = 'r';
    }
  }
  // update castling rights if rooks move or capture rooks
  if (piece === 'R' && fr === 7) {
    if (fc === 0) newCastling.whiteQueenSide = false;
    if (fc === 7) newCastling.whiteKingSide = false;
  }
  if (piece === 'r' && fr === 0) {
    if (fc === 0) newCastling.blackQueenSide = false;
    if (fc === 7) newCastling.blackKingSide = false;
  }
  const captured = stateBoard[tr][tc];
  if (captured) {
    if (captured === 'R' && tr === 7) {
      if (tc === 0) newCastling.whiteQueenSide = false;
      if (tc === 7) newCastling.whiteKingSide = false;
    }
    if (captured === 'r' && tr === 0) {
      if (tc === 0) newCastling.blackQueenSide = false;
      if (tc === 7) newCastling.blackKingSide = false;
    }
  }
  // set enPassant target if pawn moves two squares
  if (piece === 'P' || piece === 'p') {
    if (Math.abs(tr - fr) === 2) {
      newEnPassant = [(fr + tr)/2, fc];
    }
  }
  return { board:newBoard, castling:newCastling, enPassant:newEnPassant };
}

// Determine if square is attacked by attackerColor
function squareAttacked(stateBoard, r, c, attackerColor, stateCastling, stateEnPassant) {
  for (let i=0;i<8;i++) {
    for (let j=0;j<8;j++) {
      const p = stateBoard[i][j];
      if (!p) continue;
      const color = isWhitePiece(p) ? 'white' : 'black';
      if (color !== attackerColor) continue;
      const moves = getPseudoMovesForPiece(stateBoard, i, j, stateCastling, stateEnPassant);
      for (const mv of moves) {
        if (mv.to[0] === r && mv.to[1] === c) return true;
      }
    }
  }
  return false;
}

// Generate pseudo moves for a specific piece (helper for squareAttacked)
function getPseudoMovesForPiece(stateBoard, r, c, stateCastling, stateEnPassant) {
  const piece = stateBoard[r][c];
  if (!piece) return [];
  const color = isWhitePiece(piece) ? 'white' : 'black';
  return getPseudoMoves(stateBoard, color, stateCastling, stateEnPassant).filter(mv => mv.from[0] === r && mv.from[1] === c);
}

// Filter pseudo moves to legal moves (not leaving king in check)
function getLegalMoves(stateBoard, stateCastling, stateEnPassant, color) {
  const pseudo = getPseudoMoves(stateBoard, color, stateCastling, stateEnPassant);
  const legal = [];
  for (const mv of pseudo) {
    const { board:nb, castling:nc, enPassant:ne } = makeMove(stateBoard, stateCastling, stateEnPassant, mv, color);
    // find king pos
    let kingPos = null;
    for (let r2=0;r2<8;r2++) {
      for (let c2=0;c2<8;c2++) {
        const p2 = nb[r2][c2];
        if (!p2) continue;
        if (color === 'white' && p2 === 'K') kingPos = [r2,c2];
        if (color === 'black' && p2 === 'k') kingPos = [r2,c2];
      }
    }
    const opp = color === 'white' ? 'black' : 'white';
    if (kingPos && !squareAttacked(nb, kingPos[0], kingPos[1], opp, nc, ne)) {
      legal.push(mv);
    }
  }
  return legal;
}

// Evaluate board value (simple)
function evaluateBoard(stateBoard) {
  const values = { 'p': -1,'n': -3,'b': -3,'r': -5,'q': -9,'k': -1000,
                   'P': 1,'N': 3,'B': 3,'R': 5,'Q': 9,'K': 1000 };
  let score = 0;
  for (let r2=0;r2<8;r2++) {
    for (let c2=0;c2<8;c2++) {
      const p3 = stateBoard[r2][c2];
      if (p3) score += values[p3] || 0;
    }
  }
  return score;
}

// Minimax search
function minimax(stateBoard, stateCastling, stateEnPassant, depth, maximizing) {
  const color = maximizing ? 'black' : 'white';
  const legal = getLegalMoves(stateBoard, stateCastling, stateEnPassant, color);
  if (depth === 0 || legal.length === 0) {
    return { score:evaluateBoard(stateBoard) };
  }
  let bestMove = null;
  if (maximizing) {
    let bestScore = -Infinity;
    for (const mv of legal) {
      const { board:nb, castling:nc, enPassant:ne } = makeMove(stateBoard, stateCastling, stateEnPassant, mv, color);
      const result = minimax(nb, nc, ne, depth - 1, false);
      if (result.score > bestScore) {
        bestScore = result.score;
        bestMove = mv;
      }
    }
    return { score:bestScore, move:bestMove };
  } else {
    let bestScore = Infinity;
    for (const mv of legal) {
      const { board:nb, castling:nc, enPassant:ne } = makeMove(stateBoard, stateCastling, stateEnPassant, mv, color);
      const result = minimax(nb, nc, ne, depth - 1, true);
      if (result.score < bestScore) {
        bestScore = result.score;
        bestMove = mv;
      }
    }
    return { score:bestScore, move:bestMove };
  }
}

// handle board click
function handleBoardClick(event) {
  const target = event.target;
  if (!target.classList.contains('square')) return;
  const r = parseInt(target.dataset.row);
  const c = parseInt(target.dataset.col);
  const piece = board[r][c];
  const currentColor = whiteToMove ? 'white' : 'black';
  const status = document.getElementById('status');
  if (!selectedSquare) {
    if (piece && ((whiteToMove && isWhitePiece(piece)) || (!whiteToMove && isBlackPiece(piece)))) {
      selectedSquare = { row:r, col:c };
      drawBoard();
      status.textContent = 'Selected ' + piece + ' at ' + coordToAlgebraic(r,c);
    }
  } else {
    const from = [selectedSquare.row, selectedSquare.col];
    const to = [r,c];
    const legal = getLegalMoves(board, castlingRights, enPassantTarget, currentColor);
    let chosen = null;
    for (const mv of legal) {
      if (mv.from[0] === from[0] && mv.from[1] === from[1] && mv.to[0] === to[0] && mv.to[1] === to[1]) {
        chosen = mv;
        break;
      }
    }
    if (chosen) {
      const result = makeMove(board, castlingRights, enPassantTarget, chosen, currentColor);
      board = result.board;
      castlingRights = result.castling;
      enPassantTarget = result.enPassant;
      whiteToMove = !whiteToMove;
      selectedSquare = null;
      drawBoard();
      status.textContent = 'You played ' + coordToAlgebraic(from[0],from[1]) + ' to ' + coordToAlgebraic(to[0],to[1]);
      setTimeout(aiMove, 200);
    } else {
      // maybe selecting new piece or invalid
      if (piece && ((whiteToMove && isWhitePiece(piece)) || (!whiteToMove && isBlackPiece(piece)))) {
        selectedSquare = { row:r, col:c };
        drawBoard();
        status.textContent = 'Selected ' + piece + ' at ' + coordToAlgebraic(r,c);
      } else {
        selectedSquare = null;
        drawBoard();
        status.textContent = 'Move cancelled.';
      }
    }
  }
}

function aiMove() {
  if (!whiteToMove) {
    const aiColor = 'black';
    const legal = getLegalMoves(board, castlingRights, enPassantTarget, aiColor);
    if (legal.length === 0) {
      document.getElementById('status').textContent = 'Game over!';
      return;
    }
    const result = minimax(board, castlingRights, enPassantTarget, 2, true);
    const mv = result.move || legal[Math.floor(Math.random()*legal.length)];
    const next = makeMove(board, castlingRights, enPassantTarget, mv, aiColor);
    board = next.board;
    castlingRights = next.castling;
    enPassantTarget = next.enPassant;
    whiteToMove = !whiteToMove;
    drawBoard();
    document.getElementById('status').textContent = 'AI played ' + coordToAlgebraic(mv.from[0],mv.from[1]) + ' to ' + coordToAlgebraic(mv.to[0],mv.to[1]);
  }
}

initBoard();
drawBoard();
document.getElementById('board').addEventListener('click', handleBoardClick);
</script>
</body>
</html>